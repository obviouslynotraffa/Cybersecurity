Facendo una crittoanalisi del codice:
- abbiamo una funzione keygen() che genera una chiave casuale di ordine 1 tra 0 e un numero molto grande; serve per creare un numero gigantesco ma aumenta solo la complessità del file
- abbiamo una funzione mixer() che pianta un seme casuale e nuovamente esegue uno XOR tra messaggio e numero casuale

Tentando un approccio bruteforce banale, come tra l’altro già visto in altro esercizio, si ottiene la flag in una delle iterazioni. Per esempio, provando con:

for k in range(5000):
    decoded= mixer(cipher, k)
    if "spritzCTF" in decoded:
        print(decoded)

La flag è: spritzCTF{breaking_bad}
